// Virtual machine
// Creates a virtual machine to execute all the intermediate code (quadruples generated by the semantics)
// Inputs: receives the quadruples from the parser (which includes the semantic actions)
// Output: prints in the console the outputs of the execution of quadruples
// Used by: ArrowScript.js

// Helper structures
const Memory = require('./functions/helpers/memory.js')
const Stack = require('./functions/helpers/stack')

// Determine the offsets for addresses for main (stored as global on parser)
const main_func_offsets = {
	int_vars_offset: 5000,
	float_vars_offset: 9000,
	char_vars_offset: 12000,
	int_temps_offset: 8000,
	float_temps_offset: 11000,
}

// Determine the offsets for addresses for functions (stored as local on parser)
const funcs_offsets = {
	int_vars_offset: 14000,
	float_vars_offset: 19000,
	char_vars_offset: 23000,
	int_temps_offset: 18000,
	float_temps_offset: 22000,
}

// Function that checks if an address belongs to a constant (all constants are stored after virtual address 25000)
const isConstant = (address) => {
	return address >= 25000
}

// Function that returns the value of a constanst by receiving the constants directory and the address
const getConstant = (map, searchValue) => {
	for (let [key, value] of map.entries()) {
		if (value === searchValue) return key
	}
}

// Function that executes the virtual machine by creating the data, code, and stack segment
// Receives the relevant information from the parser (quads, func_directory, and constants_directory)
// Does not return anything since it performs the necessary operations inside
async function execute_virtual_machine(virtual_machine_info) {
	if (virtual_machine_info == null) {
		console.log('Expected information from parser inside virtual machine')
		throw 'Expected information from parser inside virtual machine'
	}

	// Retrieve relevant information from parser
	const { quads, func_directory, constants_directory } = virtual_machine_info

	// Declare all necessary types
	const code_segment = quads
	const data_segment = {}
	const exec_stack = new Stack()
	let ip = 0 // instruction pointer
	let current_func = 'main'

	// Create memory map for main
	// Data segment will have the form -> { main: {}, func1: {}}
	data_segment['main'] = new Memory(main_func_offsets)

	// Execute code_segment
	while (ip != -1) {
		const quad = code_segment.get(ip)
		switch (quad.operator) {
			case 1: // +
				// const left_operand = isConstant(quad.left_operand)
				// 	? getConstant(constants_directory, quad.left_operand)
				// 	: 0
				// const right_operand = isConstant(quad.right_operand)
				// 	? getConstant(constants_directory, quad.right_operand)
				// 	: 0
				// const result = left_operand + right_operand
				// Save result on memory
				// data_segment[main].push(result)
				break
			case 2: // -
			case 3: // *
			case 4: // /
			case 5: // <
			case 6: // >
			case 7: // ==
			case 8: // !=
			case 9: // &
			case 10: // |
			case 11: // =
			case 12: // print
			case 13: // read
			case 14: // gotoT
			case 15: // gotoF
				ip++
				break

			case 16: // goto
				ip = quad.result
				break
			case 17: // endfunc
			case 18: // era
			case 19: // gosub
			case 20: // param
				ip++
				break
			case 21: // end
				ip = -1
				break
			case 22: // return
				ip++
				break
			default:
				ip = -1
				break
		}
	}
}

module.exports = { execute_virtual_machine }

/*
Example using the Memory data structure
const main_memory = new Memory(main_func_offsets)
console.log('created main memory')
console.log(main_memory)
main_memory.push(1, 'vars', 'int')
main_memory.push(2, 'vars', 'int')
console.log(main_memory.memory)
main_memory.update(2, 5000, 'vars', 'int')
console.log(main_memory.memory)
console.log(main_memory.get(5001, 'vars', 'int'))
*/
